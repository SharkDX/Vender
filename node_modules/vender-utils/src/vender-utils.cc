#include "vender-utils.h"

std::string base64_chars =
"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
"abcdefghijklmnopqrstuvwxyz"
"0123456789+/";


char* base64_encode(unsigned char const* bytes_to_encode, unsigned int in_len) {
	std::string ret;
	int i = 0;
	int j = 0;
	unsigned char char_array_3[3];
	unsigned char char_array_4[4];

	while (in_len--) {
		char_array_3[i++] = *(bytes_to_encode++);
		if (i == 3) {
			char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
			char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
			char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);
			char_array_4[3] = char_array_3[2] & 0x3f;

			for (i = 0; (i < 4); i++)
				ret += base64_chars[char_array_4[i]];
			i = 0;
		}
	}

	if (i)
	{
		for (j = i; j < 3; j++)
			char_array_3[j] = '\0';

		char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
		char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
		char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);

		for (j = 0; (j < i + 1); j++)
			ret += base64_chars[char_array_4[j]];

		while ((i++ < 3))
			ret += '=';

	}

	char* result = (char*)malloc(ret.length() + 1);
	memcpy(result, ret.c_str(), ret.length());
	result[ret.length()] = '\0';
	return result;
}
                            
char* ResolveLnk(const char* linkFile)
{
	HRESULT hres;
	IShellLink* psl;
	CHAR szGotPath[MAX_PATH];
	CHAR szDescription[MAX_PATH];
	char* szPath = (char*)malloc(MAX_PATH);
	WIN32_FIND_DATA wfd;

	// Get a pointer to the IShellLink interface. It is assumed that CoInitialize
	// has already been called. 
	CoInitialize(NULL);
	hres = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_IShellLink, (LPVOID*)&psl);
	if (SUCCEEDED(hres))
	{
		IPersistFile* ppf;

		// Get a pointer to the IPersistFile interface. 
		hres = psl->QueryInterface(IID_IPersistFile, (void**)&ppf);

		if (SUCCEEDED(hres))
		{
			WCHAR wsz[MAX_PATH];

			// Ensure that the string is Unicode. 
			MultiByteToWideChar(CP_ACP, 0, linkFile, -1, wsz, MAX_PATH);

			// Add code here to check return value from MultiByteWideChar 
			// for success.

			// Load the shortcut. 
			hres = ppf->Load(wsz, STGM_READ);
			

			if (SUCCEEDED(hres))
			{
				// Resolve the link. 
				hres = psl->Resolve(NULL, SLR_NO_UI | SLR_NOSEARCH);

				if (SUCCEEDED(hres))
				{
					// Get the path to the link target. 
					hres = psl->GetPath(szGotPath, MAX_PATH, (WIN32_FIND_DATA*)&wfd, SLGP_RAWPATH);

					if (SUCCEEDED(hres))
					{
						// Get the description of the target. 
						hres = psl->GetDescription(szDescription, MAX_PATH);

						if (SUCCEEDED(hres))
						{
							// WideCharToMultiByte(CP_UTF8, 0, (LPCWCH)szGotPath, MAX_PATH, szPath, MAX_PATH, NULL, NULL);
							hres = StringCbCopy(szPath, MAX_PATH, szGotPath);

							if (SUCCEEDED(hres))
							{
								// return szPath;
								// Handle success
								return szPath;
							}
							else
							{
								return NULL;
							}
						}
					}
				}
			}

			// Release the pointer to the IPersistFile interface. 
			ppf->Release();
		}

		// Release the pointer to the IShellLink interface. 
		psl->Release();
	}
	return NULL;
}

char* ExtractIconAsBase64(char* iconPath)
{
	GdiplusStartupInput gdiplusStartupInput;
	ULONG_PTR gdiplusToken;
	GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL);
	HRESULT res;

	SHFILEINFO fileInfo;
	SHGetFileInfoA(iconPath, 0, &fileInfo, sizeof(fileInfo), SHGFI_SYSICONINDEX);

	HIMAGELIST hil;
	res = SHGetImageList(SHIL_LARGE, IID_IImageList, (void**)&hil);
	ImageList_ExtractIcon(NULL, hil, 1);
	HICON icon = ImageList_GetIcon(hil, fileInfo.iIcon, ILD_NORMAL);

	ICONINFOEX iconInfo;
	iconInfo.cbSize = sizeof(ICONINFOEX);
	GetIconInfoEx(icon, &iconInfo);

	BITMAP iconBitmap;
	GetObject(iconInfo.hbmColor, sizeof(BITMAP), &iconBitmap);
	int iconWidth = iconBitmap.bmWidth;
	int iconHeight = iconBitmap.bmHeight;

	HBITMAP hBitmap;
	BITMAPINFO bmi;
	unsigned char* pvBits = (unsigned char*)malloc(iconWidth * iconHeight * 4);

	ZeroMemory(&bmi, sizeof(BITMAPINFO));
	bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
	bmi.bmiHeader.biWidth = iconWidth;
	bmi.bmiHeader.biHeight = iconHeight;
	bmi.bmiHeader.biPlanes = 4;
	bmi.bmiHeader.biCompression = BI_RGB;
	bmi.bmiHeader.biBitCount = 32;
	bmi.bmiHeader.biSizeImage = iconWidth * iconHeight * 4;

	hBitmap = (HBITMAP)CopyImage(iconInfo.hbmColor, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
	HDC hdc = CreateCompatibleDC(NULL);
	GetDIBits(hdc, hBitmap, 0, iconHeight, pvBits, &bmi, DIB_RGB_COLORS);


	Bitmap* bitmap = Bitmap::FromBITMAPINFO(&bmi, pvBits);
	
	Bitmap* copy = new Bitmap(iconWidth, iconHeight, PixelFormat32bppARGB);
	BitmapData bmData;
	Status s = copy->LockBits(new Rect(0, 0, iconWidth, iconHeight), ImageLockModeWrite, PixelFormat32bppARGB, &bmData);
	int lineSize = iconWidth * 4;
	byte* destBytes = (byte*)(bmData.Scan0);
	for (int y = 0; y < iconHeight; y++)
	{
		memcpy(destBytes + (y * lineSize), pvBits + ((iconHeight - y - 1) * lineSize), lineSize);
	}
	copy->UnlockBits(&bmData);
	
	IStream* memstream = nullptr;
	HRESULT hr = CreateStreamOnHGlobal(NULL, TRUE, &memstream);

	CLSID pngClsid;
	CLSIDFromString(L"{557CF406-1A04-11D3-9A73-0000F81EF32E}", &pngClsid);
	
	s = copy->Save(memstream, &pngClsid);
	if (s != Status::Ok)
		return NULL;
	HGLOBAL hgMemStream = NULL;
	GetHGlobalFromStream(memstream, &hgMemStream);

	int bufsize = GlobalSize(hgMemStream);
	unsigned char *buffer = new unsigned char[bufsize];
	LPVOID ptr = GlobalLock(hgMemStream);
	memcpy(buffer, ptr, bufsize);

	GlobalUnlock(hgMemStream);
	memstream->Release();

	return base64_encode(buffer, bufsize);
}